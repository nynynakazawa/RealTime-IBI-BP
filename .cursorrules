# AI Assistant Configuration Rules（NRIインターン用）

## 概要
このファイルは AI アシスタント（Antigravity/Cursor など）の振る舞いルールを定義します。  
**AWS 設計・IAM・安全性・設計思想・MCP ツールの使い方** を明示し，**商用レベルの品質**を前提とします。

> [!IMPORTANT]
> 本ファイルは AI が自動的に参照し，プロジェクト全体のコーディング規約・設計思想・セキュリティポリシーを理解するための設定ファイルです。

---

## 基本原則

※本プロジェクトは **「商用に耐えうる設計」** と **「野村総研レベルの安全性／保守性」** を前提とする。

### 1. 宣言的なコード（Declarative Code）

- **命令的な実装（how）ではなく，何をしたいか（what）を明確に表現する**
- 状態の変更は明示的に行い，副作用を最小限に抑える
- React/Next.jsでは，JSXで宣言的にUIを記述する
- ループ処理は`map`，`filter`，`reduce`などの関数型メソッドを使用
- 条件分岐は早期リターンや三項演算子を活用して可読性を向上させる

### 2. DRY原則（Don't Repeat Yourself）

- **同じロジックやコードの重複を避ける**
- 3回以上使用されるコードは関数やコンポーネントとして抽出する
- 共通のユーティリティ関数は`utils/`または`lib/`ディレクトリに配置
- 再利用可能なコンポーネントは`components/`ディレクトリに配置
- 定数や設定値は`constants/`または`config/`に集約
- 型定義の重複を避け，共通の型は`types/`ディレクトリに配置

### 3. 拡張を見据えたコード設計

- **将来の機能追加や変更を考慮した柔軟な設計を心がける**
- インターフェースや抽象化を適切に使用し，実装の詳細を隠蔽する
- 設定や環境変数は外部化し，ハードコーディングを避ける
- プラグインやモジュール化可能な構造を意識する
- 単一責任の原則（SRP）に従い，各モジュールは一つの責任のみを持つ
- 依存性の注入やファクトリーパターンを活用して結合度を下げる

### 4. 無駄なフォールバックはしない

- **不要なデフォルト値やフォールバック処理を追加しない**
- エラーハンドリングは必要最小限に留める
- 過度なnullチェックやundefinedチェックは避ける（TypeScriptの型システムを活用）
- 実際にエラーが発生する可能性がある箇所のみエラーハンドリングを実装
- 不要なtry-catchブロックは使用しない
- オプショナルチェーン（`?.`）やnull合体演算子（`??`）は必要な場合のみ使用

### 5. 不要なコードやファイルの削除

- **使われていないものは積極的に削除する**
- 使用されていないインポート，変数，関数，コンポーネントは削除する
- コメントアウトされたコードは削除する（Git履歴に残るため）
- 未使用のファイルやディレクトリは削除する
- デッドコードや到達不可能なコードは削除する
- リファクタリング後は古いコードを確実に削除する
- 一時的なデバッグコードやconsole.logは本番コードに残さない
- 開発中はデバッグログや日本語コメントを積極的に追加し，**プロジェクト完成時にスクリプト等で一括削除する方針**とする

### 6. 分かりやすいルール化された階層構造

- プロジェクトのディレクトリ構造は一貫性を保つ
- ファイル名は明確で一貫した命名規則に従う（例: `PascalCase` for components, `camelCase` for utilities）
- 関連するファイルは同じディレクトリに配置する
- ディレクトリ名は複数形を使用（例: `components/`, `utils/`, `types/`）
- 各ディレクトリの役割を明確に定義する

### 7. クラウドアーキテクチャ設計思想（AWS 前提）

- **ステートレスを基本とし，必要なときだけステートフルなコンポーネント（EC2/ECS 等）を使う**
- 短時間のステートレス処理は **Lambda＋API Gateway** を優先し，長時間処理・WebSocket・常時接続は **EC2/ECS** に切り出す
- データストアは用途に応じて使い分ける  
  - **厳密なトランザクションや金銭処理：RDS（＋RDS Proxy）**  
  - **柔軟な JSON 永続データ：DynamoDB**  
  - **キャッシュ／TTL 前提の一時データ：Redis 等**
- 静的フロントエンドは **S3＋CloudFront** で提供し，バックエンドは **API Gateway 経由** で呼び出す構成を基本とする
- **可用性を意識し，重要なコンポーネントはマルチ AZ，オートスケーリング前提で設計する**
- 監視とログ（CloudWatch Logs，メトリクス，アラーム）を設計段階から組み込む

### 8. IAM と安全性を前提とした設計

- **「最小権限（Least Privilege）」を必ず守る**
- IAM ロール／ポリシーは，**「そのロールが本当に必要な操作だけ」** を許可する
- 人間ユーザーには IAM ユーザーではなく，可能な限り SSO 等のフェデレーションを利用することを想定する
- Lambda／EC2／ECS などの実行環境には「ロール」を付与し，**アクセスキーのハードコードは禁止**
- 役割ごとに IAM ロールを分ける（アプリケーション，運用，監査など）ことで責務を分離する
- 本番／検証／開発アカウントや VPC を分離し，誤操作で本番に影響を与えない構成を基本とする
- セキュリティグループ，NACL，WAF などネットワークレベルの防御も合わせて設計し，**多重防御（Defense in Depth）** を意識する

---

## ツール利用ポリシー（MCP / AWS Docs / Context Management）

### 9. MCP（Model Context Protocol）サーバーの活用

- **利用可能な MCP サーバーを積極的に活用し，正確な情報に基づいて実装する**
- 主要な MCP サーバー：
  - **AWS Documentation MCP**: AWS サービスの公式ドキュメント参照
  - **Context7**: コードベース全体の意味的検索・理解支援
  - その他プロジェクト固有の MCP サーバー
- MCP サーバーの使い分け：
  - AWS 関連の仕様確認 → AWS Documentation MCP
  - コードベース内の類似実装検索 → Context7
  - 外部 API 仕様確認 → 該当する MCP サーバーまたは公式ドキュメント

### 10. AWS 関連調査の優先度

- **AWS に関する仕様・設計・ベストプラクティスを調べるときは，常に「AWS Documentation MCP」を最優先で利用する**
  - 例：サービス仕様／制限値／ベストプラクティス／セキュリティ設計 など
- そのほかの情報源（ブログ・Qiita 等）よりも，**まず公式ドキュメントを参照してから** 実装方針を決める
- **曖昧な理解のままコードを書かず，「ドキュメントを先に読む」ことを徹底する**

### 11. Context7 を用いたコードベース理解

- **Context7 は意味的検索により，コードベース全体から関連する実装を発見するツール**
- 以下の場合に Context7 を活用する：
  - 新機能実装時に既存の類似実装パターンを探す
  - 特定の機能がどこで使われているかを横断的に調査する
  - 命名規則や設計パターンの一貫性を確認する
  - リファクタリング時に影響範囲を把握する
- **Context7 の検索結果を参考に，既存コードとの一貫性を保った実装を心がける**

### 12. コンテキスト取得とトークンの使い方

- **多くのトークンを使ってよいので，関連ファイルをできるだけ広く読み，コンテキストを把握してからコードを書く**
- 具体的には以下を行う：
  - 関連しそうなディレクトリを **積極的に開いて読む**（`app/`, `components/`, `lib/`, `utils/`, `types/`, `infra/` など）
  - 型定義（`types/`）とドメインモデルを先に読む
  - API ハンドラやバックエンド（Lambda / API Route 等）の実装を把握してからフロントの修正に入る
  - インフラ周り（CDK / Terraform / CloudFormation）がある場合は**必ず一度目を通し，既存リソース名・構造を理解してから**変更提案をする
- **部分的なファイルだけを見て推測で書かず，「全体像 → 局所変更」の順番で考える**
- Context7 や codebase_search を使って関連コードを事前に調査し，実装の一貫性を確保する

### 13. 変更提案とコード生成の姿勢

- **既存の設計思想や命名規則に合わせることを最優先する**
- 大きなリファクタリングや設計変更が必要だと感じた場合も，いきなり書き換えず：
  - 「現状の問題点の整理」
  - 「小さなステップに分割した改善案」
  - 「互換性に配慮した移行案」
  をコメントや説明テキストとしてまず示す
- コード生成時は：
  - **型定義 → インターフェース → 実装 → テスト** の順で意識して設計する
  - エラーハンドリングとログ出力の方針を最初に決める
  - Context7 で既存の類似実装を検索し，パターンを踏襲する

---

## ディレクトリ構造のルール

> [!NOTE]
> プロジェクトの種類に応じて適切なディレクトリ構造を採用する。  
> 以下は Next.js プロジェクトの例だが，他のフレームワークでも同様の原則を適用する。

### 標準的なディレクトリ構成（Next.js の場合）

```txt
app/                    # Next.js App Router（ページルーティング）
├── (routes)/           # ルートグループ（URLに影響しないグループ化）
├── components/         # ページ固有のコンポーネント
├── layout.tsx          # レイアウトコンポーネント
└── page.tsx            # ページコンポーネント

components/             # 再利用可能な共通コンポーネント
├── ui/                 # UIプリミティブコンポーネント（Button, Input等）
└── features/           # 機能別コンポーネント（UserProfile, Dashboard等）

lib/                    # ライブラリ設定や初期化
                        # 例：AWS SDK クライアント，外部APIクライアント，DB接続等
utils/                  # ユーティリティ関数（汎用的なヘルパー関数）
types/                  # TypeScript型定義（共通の型・インターフェース）
constants/              # 定数定義（API エンドポイント，権限スコープ名，設定値等）
hooks/                  # カスタムフック（React hooks）

infra/                  # インフラストラクチャコード（CDK/Terraform/CloudFormation等）
scripts/                # ビルド・デプロイ・メンテナンス用スクリプト
```

### ディレクトリ配置の原則

- **関心の分離**: 各ディレクトリは明確な責務を持つ
- **再利用性**: 共通コンポーネントは `components/` に，ページ固有は `app/` 内に配置
- **検索性**: ファイル名と配置場所から機能が推測できるようにする
- **スケーラビリティ**: プロジェクトの成長に合わせて拡張可能な構造を維持する

---

## コーディング規約

### TypeScript

- **型安全を最優先する**
  - 型推論を活用し，明示的な型アノテーションは必要な場合のみ使用
  - `any` 型の使用は避け，ジェネリック型や `unknown` や適切な型定義を使用
  - API のレスポンス型やドメインオブジェクトは必ず型定義し，曖昧な `any` を許容しない
- **型の使い分けを明確にする**
  - インターフェース（`interface`）: オブジェクトの形状を定義，拡張可能
  - タイプエイリアス（`type`）: ユニオン型，交差型，プリミティブ型のエイリアス
- **ジェネリクスを活用して再利用性を高める**
  - 汎用的な関数やコンポーネントはジェネリック型を使用
  - 型パラメータには意味のある名前を付ける（`T` だけでなく `TData`, `TResponse` など）

### React/Next.js

- **コンポーネント設計**
  - コンポーネントは関数コンポーネントを使用（クラスコンポーネントは使用しない）
  - カスタムフックでロジックを分離し，コンポーネントは UI に集中させる
  - Server Components を優先し，クライアントコンポーネント（`'use client'`）は必要な場合のみ使用
- **パフォーマンス最適化**
  - `useMemo`, `useCallback` は必要な場合のみ使用（過度な最適化は避ける）
  - 実際にパフォーマンス問題が確認された箇所のみ最適化する
- **セキュリティ**
  - 認証情報やトークンの処理はできる限りサーバー側で行う
  - クライアントに機微情報を持たせすぎない（環境変数の使い分けに注意）

### 命名規則

| 対象 | 形式 | 例 |
|------|------|-----|
| コンポーネント | PascalCase | `UserProfile.tsx`, `LoginButton.tsx` |
| 関数・変数 | camelCase | `getUserData`, `isAuthenticated` |
| 定数 | UPPER_SNAKE_CASE | `API_BASE_URL`, `MAX_RETRY_COUNT` |
| 型・インターフェース | PascalCase | `UserData`, `ApiResponse<T>` |
| ファイル名（コンポーネント） | PascalCase | `UserProfile.tsx` |
| ファイル名（その他） | camelCase | `authUtils.ts`, `apiClient.ts` |

- **命名の原則**
  - 名前から目的・役割が明確に分かるようにする
  - 略語は一般的なもののみ使用（`id`, `url`, `api` など）
  - ブール値は `is`, `has`, `should` などの接頭辞を使用（例: `isLoading`, `hasError`）

### インポート順序

インポート文は以下の順序で記述し，各グループ間に空行を入れる：

1. **外部ライブラリ**（React, Next.js, サードパーティライブラリ等）
2. **内部モジュール**（`@/components`, `@/utils`, `@/lib` 等のエイリアスインポート）
3. **相対パスインポート**（`./`, `../` で始まるインポート）
4. **型インポート**（`import type` を使用した型のみのインポート）

```typescript
// 1. 外部ライブラリ
import React from 'react';
import { NextPage } from 'next';

// 2. 内部モジュール
import { Button } from '@/components/ui/Button';
import { formatDate } from '@/utils/dateUtils';

// 3. 相対パスインポート
import { LocalComponent } from './LocalComponent';

// 4. 型インポート
import type { UserData } from '@/types/user';
```

### コメント

- **コメントの基本方針**
  - 複雑なロジックには説明コメントを追加（なぜそうするのかを説明）
  - 自明なコードにはコメントを追加しない（コードが何をするかは読めば分かる）
  - 関数やコンポーネントには JSDoc コメントを追加（公開 API の場合は必須）
- **開発中のコメントとログ**
  - 開発中は積極的に日本語のコメントを追加し，処理の意図や動作を明確に記述する
  - デバッグログ（`console.log`, `logger.debug` 等）も開発中は積極的に追加する
  - **プロジェクト完成時にスクリプト等で一括削除する方針**とする
- **TODO コメントの扱い**
  - TODO コメントは避け，Issue やタスク管理ツールを使用する
  - やむを得ず TODO を残す場合は，Issue 番号を併記する（例: `// TODO(#123): ...`）

---

## エラーハンドリング

- **エラーの基本方針**
  - エラーは「握りつぶさず」，適切なレイヤでキャッチして意味のあるメッセージに変換する
  - 予期しないエラーは上位に伝播させる（適切なエラーバウンダリで処理）
- **ユーザー向けエラー表示**
  - エラーは適切なレベルでキャッチし，ユーザーに分かりやすいメッセージを表示
  - 技術的な詳細はログに記録し，ユーザーには簡潔なメッセージを表示
- **ログとモニタリング**
  - エラーログは構造化された形式で記録し，CloudWatch Logs 等に集約する
  - エラーの文脈情報（ユーザー ID，リクエスト ID 等）を含める
- **リトライとタイムアウト**
  - リトライロジックは必要な場合のみ実装（冪等性を確保）
  - 外部 API にはタイムアウトと最大リトライ回数を設定する
  - Lambda ではタイムアウトを意識し，処理時間が超過しそうなものは設計を見直す（分割，SQS キューイングなど）

---

## パフォーマンス

### フロントエンド最適化

- **React パフォーマンス**
  - 不要な再レンダリングを避ける（`React.memo`, `useMemo`, `useCallback` を適切に使用）
  - コード分割を適切に使用（動的インポート，React.lazy）
- **アセット最適化**
  - 画像は最適化された形式を使用（Next.js Image コンポーネント，WebP 形式等）
  - バンドルサイズを意識し，不要な依存関係を避ける
  - Tree shaking が効くように named import を使用

### バックエンド最適化

- **データベース接続**
  - DB 接続は接続プール（RDS Proxy 等）を利用する
  - Lambda からのコネクション急増で DB を落とさないよう設計する
- **キャッシュ戦略**
  - キャッシュ（CloudFront，Redis 等）を適切に挟み，不必要なオリジンアクセスを避ける
  - キャッシュの TTL を適切に設定し，データの鮮度とパフォーマンスのバランスを取る

---

## セキュリティ

> [!CAUTION]
> セキュリティは設計段階から組み込む。後付けでの対応は困難かつ不完全になりやすい。

### IAM / アクセス制御

- **最小権限の原則（Least Privilege）**
  - IAM ロール／ポリシーは「最小権限」を徹底する
  - サービス間アクセス（Lambda→RDS，Lambda→DynamoDB など）は IAM ロールベースで行う
  - **アクセストークンやキーの直書きは禁止**
- **環境分離**
  - 開発用と本番用でロールを分離し，本番ロールを安易に使い回さない
  - 人手での操作は管理ロールを最小限のメンバーに限定する

### ネットワーク設計

- **多重防御（Defense in Depth）**
  - VPC，サブネット，セキュリティグループで通信経路を明確に制限する
  - DB はプライベートサブネットに配置し，インターネットから直接アクセスさせない
  - CloudFront＋WAF＋API Gateway を組み合わせ，L7 レベルでの防御も行う

### 機密情報・ログ

- **入力検証とサニタイゼーション**
  - ユーザー入力は必ず検証・サニタイズする
  - XSS や CSRF 対策を適切に実装する
- **機密情報の管理**
  - 機密情報は環境変数や Secrets Manager で管理し，Git に含めない
  - API キーやトークンはクライアント側に露出しない
- **ログとモニタリング**
  - ログには個人情報や機密情報を可能な限り出力しない（トークン／パスワードはマスクする）
  - アクセスログ（CloudTrail など）により**「誰がいつ何をしたか」**を追跡できる状態を保つ

---

## テスト

- **テストの基本方針**
  - 重要なビジネスロジックには必ずテストを書く
  - テストは実装と同時に書く（TDD を推奨）
  - テストファイルは対象ファイルと同じディレクトリに `*.test.ts` または `*.spec.ts` として配置
- **テスタビリティの確保**
  - AWS SDK を用いる箇所は，可能な限りインターフェースで抽象化し，モックしやすい構造にする
  - 依存性注入を活用し，外部サービスへの依存を減らす
- **テストの種類**
  - **単体テスト**: 関数やクラスの個別の動作を検証
  - **統合テスト**: 複数のモジュールやサービスの連携を検証
  - **E2E テスト**: ユーザーの操作フローを検証（重要な機能のみ）

---

## バックエンド開発

### N+1 問題の回避

- **クエリの最適化**
  - データベースクエリは可能な限り JOIN やサブクエリを使用して 1 回のクエリで取得する
  - ループ内でのデータベースアクセスは避け，バッチ処理や一括取得を優先する
- **ORM の最適化**
  - ORM を使用する場合は，`select_related` や `prefetch_related` などの最適化機能を活用する
  - 複数のレコードを挿入・更新する場合は，バルクインサートやバルクアップデートを使用する

### ブロッキングとノンブロッキングの使い分け

- **非同期処理の活用**
  - I/O 待機が発生する処理（API 呼び出し，データベースアクセス，ファイル操作）は非同期処理を検討する
  - 複数の独立した I/O 処理がある場合は，並列実行を優先する
- **処理の種類による使い分け**
  - CPU 集約的な処理は同期的に実行し，I/O 待機が発生する処理は非同期に実行する
  - Lambda 関数など実行時間に制限がある環境では，並列処理で実行時間を短縮する

### 並列処理の実装

- **並列実行の基本**
  - 複数の独立した API リクエストは `Promise.all` で並列実行する
  - データベースのバッチ操作はバルク操作を使用する
- **リソース管理**
  - 並列処理の数は適切に制限し，リソースの枯渇を防ぐ
  - エラーハンドリングは各並列処理で個別に行い，一部の失敗が全体に影響しないようにする

### 冪等性の確保

- **API の冪等性**
  - API エンドポイントは可能な限り冪等性を保証する（同じリクエストを複数回実行しても同じ結果になる）
  - データベースの INSERT 操作は UPSERT を使用して冪等性を確保する
- **外部 API との連携**
  - 外部 API を呼び出す場合は，リトライ時に冪等性を考慮した実装にする
  - 金銭や在庫などのクリティカルな処理にはトランザクションやロック機構を使用する

### データベース最適化

- **クエリ最適化**
  - インデックスを適切に設定し，クエリパフォーマンスを最適化する
  - 大量のデータを扱う場合は，ページネーションやカーソルベースのページングを実装する
- **接続管理**
  - 接続プールを適切に設定し，接続の再利用を最適化する（RDS Proxy など）
  - トランザクションのスコープを最小限にし，ロック時間を短縮する

### API 設計

- **RESTful 設計**
  - RESTful な設計原則に従う
  - 適切な HTTP ステータスコードを使用する（200, 201, 400, 401, 403, 404, 500 など）
- **API の保護と管理**
  - リクエスト/レスポンスの形式を統一する（JSON 形式を推奨）
  - レート制限や WAF を組み合わせ，API の過剰な使用を防ぐ
  - バージョニングを適切に実装する（URL パスまたはヘッダーで管理）

---

## 外部サービス操作

> [!WARNING]
> 外部サービス（AWS, GCP, Vercel など）への操作は慎重に行う。特に本番環境への変更は必ずユーザーの承認を得る。

### 状態確認とログ確認

- **CLI を使った状態確認**
  - GCP，AWS，Vercel などの外部サービスの状態確認は基本的に CLI を使用する
  - ログや構造を確認しながら作業を進める
  - `aws logs`, `aws cloudwatch`, `vercel logs` などを活用して現在の状態を把握する
  - リソースの一覧表示や設定の確認は積極的に行う

### 危険な操作の制限

> [!CAUTION]
> 以下の操作は基本的に実行しない。必要不可欠な場合のみ，ユーザーの明示的な承認を得てから実行する。

**実行禁止操作（ユーザー承認必須）**:
- コンテナの新規作成（ECS，Cloud Run，Kubernetes など）
- 設定変更（セキュリティグループ，IAM ポリシー，ネットワーク設定など）
- 関数の削除（Lambda，Cloud Functions など）
- 環境変数の変更（特に本番環境）
- 機密情報のアップロード（API キー，パスワード，トークンなど）
- データベースの削除やスキーマ変更
- リソースの削除全般

### 確認プロンプトの実装

- **安全性の確保**
  - 危険な操作を実行する必要がある場合は，CLI 上で確認プロンプトを表示し，"y" を入力しないと進めないようにする
  - 実行前に影響範囲とリスクを明確に説明する

### データ構造の理解

- **データ構造の把握**
  - バックエンドのデータ構造を理解しながら作業を進める
  - DynamoDB や RDB の確認用スクリプトを作成し，テーブル構造やデータの状態を確認できるようにする
- **確認用スクリプトの管理**
  - 確認用スクリプトは `scripts/` ディレクトリに配置し，読み取り専用の操作を中心に実装する
  - データ構造の変更が必要な場合は，マイグレーションスクリプトを作成し，十分な検証を行ってから実行する

---

## Git コミット

- **コミットメッセージの原則**
  - コミットメッセージは明確で日本語で説明的にする
  - 1 つのコミットは 1 つの変更に集中する（単一責任の原則）
  - インフラ変更（IAM，セキュリティグループ，VPC 等）に関係するコードは，コミットメッセージで分かるようにしておく
    - 例: 「IAM ロールの最小権限化」「セキュリティグループのインバウンドルール追加」
- **コミットに含めないもの**
  - 不要なファイル（`node_modules`, `.env`, ビルド成果物等）はコミットしない
  - `.gitignore` を適切に設定し，機密情報や自動生成ファイルを除外する

---

## まとめ

このファイルは AI アシスタントが自動的に参照し，プロジェクト全体の設計思想・コーディング規約・セキュリティポリシーを理解するための設定ファイルです。

**重要な原則**:
1. **商用レベルの品質**を前提とする
2. **最小権限の原則**を徹底する
3. **MCP ツール（AWS Docs, Context7 等）を積極的に活用**する
4. **既存コードとの一貫性**を保つ
5. **セキュリティは設計段階から組み込む**